# Data Types
Java is a **strongly typed language**, this means that every variable must have a declared type.

## char
Literal values of type **char** are enclosed in single quotes.

'A', '\n', '\u2122'

Unicode escape sequences are processed before the code is parsed, so **public static void main(String\u005B\u005D args)** is perfectly legal.

In Java, the char type describes a **code unit** in the UTF-16 encoding. So some Unicode characters can be described with one char value, and other Unicode characters require two char values. 

One strong recommendation is not to use the char type in your programs unless you are actually manipulating UTF-16 code units.

## boolean
true, false

## conversions between numeric types
Automatic conversions:
- byte --> short
- char --> int
- short --> int
- int --> long
- int --> double
- float --> double
- int --> float (may lose precision)
- long --> float (may lose precision)
- long --> double (may lose precision)

Conversions in which loss of information is possible are done by means of **cast**. The syntax for casting is to give the target type in parentheses, followed by the variable name.

# Variables
A variable name must begin with a letter and must be a sequence of letters or digits. A letter is defined as 'A'-'Z', 'a'-'z', '\_', '\$', or any Unicode character that denotes a letter in a language. Similarly, digits are '0'-'9' and any Unicode character that denotes a digit in a language.

```java
		int 我是个变量 = 4;
		System.out.println(我是个变量);
```

Even though '\$' is a valid Java letter, you should not use it in your own code. It is intended for names that are generated by the Java compiler and other tools.

The length of a variable name is essentially unlimited.

After you declare a variable, you must explicitly initialize it by means of an assignment statement, you can never use the value of an uninitialized variable.

in Java, you use the keyword **final** to denote a constant. It is customary to name constants in all uppercase.

Sometimes, a variable should only hold a restricted set of values. You can define your own **enumerated type** whenever such a situation arises. An enumerated type has a finite number of named values.

# Strings
Java strings are immutable.

Do not use the == operator to test whether two strings are equal. If the virtual machine always arranges for equal strings to be shared, then you could use the == operator for testing equality. But only string literals are shared, not strings that are the result of operations like + or substring.

Every time you concatenate strings, a new **String** object is constructed. This is time consuming and wastes memory. Using the **StringBuilder** class avoids this problem.

# Input and Output

# Control Flow
A block or compound statement consists of a number of Java statements, surrounded by a pair of braces. Blocks define the scope of your variables. A block can be nested inside another block. You may not declare identically named variables in two nested blocks.

A switch case label can be:
- a constant expression of type char, byte, short, or int
- an enumerated constant
- a string literal (Java SE7)

Java also offers a **labeled break** statement that lets you break out of multiple nested loops.
```java
label:
while (xxx) {
	xxx;
	for (...) {
		xxx;
		break label;
	}
}
```

# Big Numbers
**BigInteger** and **BigDecimal** are classes for manipulating numbers with an arbitrary long sequence of digits. The **BigInteger** class implements arbitrary-precision integer arithmetic, and **BigDecimal** class does the same for floating-point numbers.

# Arrays
An array is a data structure that stores a collection of values of the same type.

Once you create an array, you cannot change its length. The array length may not be a constant, **new int[n]** creates an array of length n. It is legal to have arrays of length 0. Such an array can be useful if you write a method that computes an array result and the result happens to be empty.

An array of objects in Java is an array of references to objects, not the objects themselves. Primitive arrays work just like object arrays except that primitive arrays hold the primitive values directly.

A Java array is quite different from a C++ array on the stack. Java array is essentially the same as a pointer to an array allocated on the heap.

Java has no multidimensional arrays at all, only one-dimensional arrays. Multidimensional arrays are faked as "arrays of arrays".









A **class** is the template or blueprint from which objects are made.

Encapsulation is a key concept in working with objects.

Classes can be built by extending other classes. The concept of extending a class to obtain another class is called **inheritance**.

A simple rule of thumb in identifying classes is to look for nouns in the problem analysis. Methods, on the other hand, correspond to verbs.

Relationships between classes:
- dependence ("uses-a"): a class depends on another class if its methods use or manipulate objects of that class
- aggregation ("has-a")
- inheritance ("is-a")

In Java, the value of any object variable is a reference to an object that is stored elsewhere. It is important to realize that an object variable doesn't actually contain an object. It only refers to an object. You can explicitly set an object variable to **null** to indicate that it currently refers to no object.

All Java objects live on the heap. When an object contains another object variable, it contains just a pointer to yet another heap object.

Constructors:
- a constructor has the same name as the class
- a class can have more than one constructors
- a constructor can take zero, one, or more parameters
- a constructor has no return value
- a constructor is always called with the new operator

Be careful not to write accessor methods that return references to mutable objects. If you need to return a reference to a mutable object, you should **clone** it first. As a rule of thumb, always use **clone** whenever you need to return a copy of a mutable field.

A method can access the private features of any object of its class, not just of the implicit parameter:
```java
class Employee {
	public boolean equals(Employee other) {
		return name.equals(other.name);
	}
}
```

Final instance fields: You can define an instance field as **final**. Such a field must be initialized when the object is constructed. That is, you must guarantee that the field value has been set after the end of every constructor. The **final** modifier is particularly useful for fields whose type is primitive or an **immutable** class. A class is immutable if none of its methods ever mutate its objects. For example, the **String** class is immutable.

The term **call by value** means that the method gets just the value that the caller provides. In contrast, **call by reference** means that the method gets the location of the variable that the caller provides. Thus, a method can modify the value stored in a variable passed by reference but not in one passed by value.

The Java programming language always uses call by value. That means that the method gets a copy of all parameter values. In particuar, the method cannot modify the contents of any parameter variables passed to it. There are two kinds of method parameters: primitive types and object references. A method cannot modify a parameter of a primitive type, or make an object parameter refer to a new object, but a method can change the state of an object parameter.

If you don't set a field explicitly in a constructor, it is automatically set to a default value: numbers to 0, boolean values to false, and object references to null. This is an important difference between fields and local variables. You must always explicitly initialize local variables in a method. But in a class, if you don't initialize a field, it is automatically initialized to a default (0, false, or null).

Please keep in mind that you get a free no-argument constructor only when your class has no other constructors. If a class supplies at least one constructor but does not supply a no-argument constructor, it is illegal to construct objects without supplying arguments.

You can simply assign a value to any field in the class definition. This assignment is carried out before the constructor executes. This syntax is particularly useful if all constructors of a class need to set a particular instance field to the same value.

If the first statement of a constructor has the form **this(...)**, then the constructor calls another constructor of the same class.

Initialization block: class declarations can contain arbitrary blocks of code. These blocks are executed whenever an object of that class is constructed. This mechanism is never necessary and is not common. It is usually more straightforward to place the initialization code inside a constructor. If you want to use initialization blocks, we suggest that you always place initialization blocks after the field definitions.

When a constructor is called:
1. If the first line of the constructor calls a second constructor, then the second constructor executes with the provided arguments.
2. Otherwise,
(a) All data fields are initialized to their default values (0, false, null). 
(b) All field initializers and initialization blocks are executed, in the order in which they occur in the class declaration
3. The body of the constructor is executed.

Static field initialization:
To initialize a static field, either supply an initial value or use a static initialization block. Static initialization occurs when the class is first loaded. Like instance fields, static fields are 0, false, or null unless you explicitly set them to another value. All static field initializers and static initialization blocks are executed in the order in which they occur in the class declaration.

Locating classes in packages is an activity of the compiler. The bytecodes in class files always use full package names to refer to other classes.

In Java, you can entirely avoid the **import** mechanism by explicitly naming all classes.

Place source files into a subdirectory that matches the full package name. The compiler does not check the directory structure when it compiles source files. However, the resulting program will not run unless you first move all class files to the right place. The virtual machine won't find the classes if the packages don't match the directories.

A JAR file contains multiple class files and subdirectories in a compressed format, saving space and improving performance. When you use a third-party library in your programs, you will usually be given one or more JAR files to include.

JAR files use the ZIP format to organize files and subdirectories. You can use any ZIP utility to peek inside JAR files.

The class path is the collection of all locations that can contain class files. It lists all directories and archive files that are starting points for locating classes.
- the base directory
- the current directory
- the JAR file

It is best to specify the class path with the **-classpath** option.

How does the JVM locate classes? Suppose the class path is /home/user/classdir:.:/home/user/archives/archive.jar, and we need to search for the class file of the com.horstmann.corejava.Employee class:
- it first looks in the Java API classes
- then it looks for the following files: /home/user/classdir/com/horstmann/corejava/Employee.class, com/horstmann/corejava/Employee.class starting from the current directory, com/horstmann/corejava/Employee inside /home/user/archive/archive.jar

How does the compiler locate classes? The compiler has a harder time locating files than does the virtual machine. If you refer to a class without specifying its package, the compiler first needs to find out the package that contains the class. It consults all **import** directives as possible sources for the class. It searches for each of these classes in all of the locations of the class path. It is a compile-time error if more than one class is found. Classes must be unique, so the order of the import statements doesn't matter. The compiler goes one step further. It looks at the source files to see if the source is newer than the class file. If so, the source file is recompiled automatically.

Class Design Hints:
- Always keep data private
- Always initialize data
- Don't use too many basic types in a class: the idea is to replace multiple related uses of basic types with other classes
- Not all fields need individual field accessors and mutators
- Break up classes that have too many responsibilities
- Make the names of your classes and methods reflect their responsibilities
- Prefer immutable classes

# JAR
JAR files are compressed, using the familiar ZIP compression format.

The manifest file is called MANIFEST.MF and is located in a special META-INF subdirectory of the JAR file.

A manifest is a description of the archive contents and origin. Every archive has a default manifest, but you can supply your own if you want to authenticate the contents of the archive.









# Superclasses and Subclasses
Some people think of **super** as being analogous to the **this** reference. However, that analogy is not quite accurate: **super** is not a reference to an object. For example, you cannot assign the value **super** to another object variable. Instead, **super** is a special keyword that directs the compiler to invoke the superclass method.

subclass继承下来的methods可能并不适用，那就需要override the superclass method
当你override某个method时，你必须保证return type是compatible的，a subclass may change the return type to a subtype of the original type
public Employee getBuddy() {...}
public Manager getBuddy() {...}
当你override某个method时，subclass method至少要as visible as the superclass mehtod
如果superclass method是public的，那么对应的subclass method也必须是public的

(2)constructors
subclass的constructor如何呢？subclass的constructor必须先调用superclass的constructor来初始化它继承下来的private fields，如果subclass没有显式调用superclass的constructor，那么就会自动调用superclass的no-argument constructor，如果superclass恰好没有no-argument constructor，那么compiler会报错
如何调用superclass的constructor呢？
super(...)
the constructor calls can only occur as the first statement in another constructor. The constructor parameters are either passed to another constructor of the same class (this) or a constructor of the superclass (super)

(3)polymorphism and dynamic binding
e.getSalary()
note that the declared type of e is Employee, but the actual type of the object to which e refers can be either Employee or Manager
the virtual machine knows about the actual type of the object to which e refers, and therefore can invoke the correct method
polymorphism
the fact that an object variable can refer to multiple actual types is called polymorphism
in Java, object variables are polymorphic
a variable of type Employee can refer to an object of type Employee or to an object of any subclass of  the Employee class
Manager boss = new Manager(...); Employee[] staff = new Employee[3]; staff[0] = boss;
 the variables staff[0] and boss refer to the same object. However, staff[0] is considered to be only an Employee object by the compiler
什么意思呢？虽然staff[0]和boss指向同一个object，但是对于compiler来说，staff[0]指向的object只能被当作Employee，而boss指向的object才可以当作Manager，所以boss.setBonus(5000)没有问题，但staff[0].setBonus(5000)是不行的
反过来，you cannot assign a superclass reference to a subclass variable
也就是说，可以替父从军，subclass objects可以冒充superclass objects，但反过来不行
Manager[] managers = new Manager[3]; Employee[] staff = managers;
这样赋值没有问题
staff[0] = new Employee(...)
报错ArrayStoreException
all arrays remember the element type with which they were created, and they monitor that only compatible references are stored into them
dynamic binding
automatically selecting the appropriate method at runtime is called dynamic binding
dynamic binding has a very important property: it makes programs extensible without the need for modifying existing code

(4)x.f(args)这样的method calls背后发生了什么呢？
the compiler looks at the declared type of the object and the method name
the compiler enumerates all methods called f in the class C and all accessible methods called f in the superclasses of C
现在，compiler掌握了所有潜在的candidates for the method to be called
next, the compiler determines the types of the arguments that are supplied in the method call
这一步就是overloading resolution
the situation can get complex because of type conversions，比如int to double, Manager to Employee
if the compiler cannot find any method with matching parameter types or if multiple methods all match after applying conversions, the compiler reports an error
现在，compiler确定了the name and parameter types of the method to be called
if the method is private, static, final, or a constructor, then the compiler knows exactly which method to call. Otherwise, the method to be called depends on the actual type of the implicit parameter
这里是static binding和dynamic binding的区别
static binding就是已经可以明确调用哪一个method，dynamic binding还得在运行时基于implicit parameter的具体类型来决定调用哪一个method
when the program runs and uses dynamic binding to call a method, the virtual machine must call the version of the method that is appropriate for the actual type of the object to which x refers
每次method call都这样搜索一遍很没有效率，所以virtual machine会提前为每个class计算出一个method table that lists all method signatures and the actual methods to be called，真正调用method时，做一个table lookup就好了

(5)final classes and methods
有的时候，你需要某个class是不能被扩展的，你只需要在class definition中用final修饰符就可以了
classes that cannot be extended are called final classes
if a class is declared final, then all the methods, but not the fields, are automatically final
有的时候，你需要某个method是不能被override的，你只需要在method definition中用final修饰符就可以了
为什么要使用final class或final method？to make sure its semantics cannot be changed in a subclass

(6)obejct reference casting
有的时候，你可能需要把object reference从一种类型转换到另一种类型
一般只有一种情形有这种需求：to use an object in its full capacity after its actual type has been temporarily forgotten
我们知道，在Java中每个变量都有自己的类型，the type describes the kind of object the variable refers to and what it can do
当你向这个variable中存值时，compiler要确保你没有promise more，比如你将subclass reference赋值给superclass variable，这等于是promise less，没有问题；但如果你将superclass reference赋值给subclass variable，你就是在promise more，那么你必须使用cast，提醒JVM进行runtime checking
那如果你试图作假呢？并不是你用了cast就万事OK了，JVM会做运行时检查看转换是否有效，无效就会抛出ClassCastException
it is good programming practice to find out whether a cast will succeed before attempting it
if (staff[1] instanceof Manager) { boss = (Manager) staff[1]; ... }
the compiler will not let you make a cast if there is no chance for the cast to succeed
String s = (String) staff[1]; compile-time error
总之，在inheritance hierarchy中，由下到上不需要cast，但由上到下必须cast，cast前应当使用instanceof判断是否有效
actually, converting the type of an object by a cast is not usually a good idea. In general, it is best to minimize the use of casts and the instanceof operator

(7)abstract classes and abstract methods
abstract methods
public abstract String getDescription();
abstract methods act as placeholders for methods that are implemented in the subclasses
如果一个class中有一个或多个abstract methods，那么这个class也必须用abstract来修饰
subclass继承abstract class时，除非把所有abstract methods都具化，否则也得用abstract来修饰
abstract classes
在inheritance hierarchy中，越往上就越抽象，一直抽象到the ancestor class becomes so general that you think of it more as a basis for other classes than as a class with specific instances you want to use
比如，Employee和Student都继承自Person，Person就是足够抽象的class
abstract class不是只能包含abstract methods，一样可以包含fields和concrete methods
一个class即便没有abstract methods，也可以用abstract来修饰
abstract classes cannot be instantiated
你依然可以定义abstract class类型的object variables，but such a variable must refer to an object of a nonabstract subclass

(8)protected access
有时候我们会碰到以下需求：
允许subclass access superclass的fields
只针对subclass放开某些methods的访问权（public是对所有人放开访问权，private是完全不放开访问权）
那么怎么办呢？我们还有一个access modifier，那就是protected，使用protected就可以满足上面两个需求
protected fields要尤其注意，因为一定程度上这违反了OOP的encapsulation原则，你针对protected fields的改动可能会影像使用这个class的人
protected methods还有一些合理之用，比如Object的clone method

(9)four access modifiers
private
visible to the class only
public
visible to the world
protected
visible to all subclasses and the package
protected features in Java are visible to all subclasses as well as to all other classes in the same package
default
visible to the package

5.2 Object
(1)Object是终极祖先，所有classes都继承于Object
you can use a variable of type Object to refer to objects of any type. To do anything specific with the value, you need to have some knowledge about the original type and apply a cast
Object obj = new Employee(...);
Employee e = (Employee) obj;
in Java, only the values of primitive types (numbers, characters, and boolean values) are not objects. All array types, no matter whether they are arrays of objects or arrays of primitive types, are class types that extend the Object class

(2)equals
Object提供了最基础的equals method，即如果x和y指向同一个object，那么它们显然equals
对于很多classes，Object的equals已经满足使用了；但是对于某些classes，它们可能有根据objects states判断是否equals的需求，而不是强制要求必须指向同一个object，此时你就需要重载equals方法了
当你重写equals ethod时，Java标准有一些要求，equals method必须满足：
reflexive
for any non-null reference x, x.equals(x) should return true
symmetric
for any referecnes x and y, x.equals(y) should return true if and only if y.equals(x) returns true
transitive
for any references x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true
consistent
if the objects to which x and y refer haven't changed, then repeated calls to x.equals(y) return the same value
null reference
for any non-null referece x, x.equals(null) should return false
根据x和y的class types的关系，我们有：
如果x和y的class types相同，那么无论是依据是否指向同一个object还是依据states判断，都没有问题
如果x和y的class types没关系，那么返回false
如果x和y的class types有继承关系呢？这就比较麻烦了
if subclasses can have their own notion of equality, then the symmetry requirement forces you to use the getClass test
if the notion of equality is fixed in the superclass, then you can use the instanceof test and allow objects of different subclasses to be equal to one another
也就是说，如果subclasses需要特殊对比，那你就严格限制x和y的class type相同（getClass）；如果subclasses不需要特殊对比，那你应该放宽限制（instanceof），并把superclass中的equals声明为final
equals recipe
if (this == otherObject) return true;
if (otherObject == null) return false;
if (getClass() != otherObject.getClass()) return false;或if (!(otherObject instanceof ClassName)) return false;
ClassName other = (ClassName) otherObject;
return field1 == other.field1 && Objects.equal(field2, other.field2) && ...;
when you define the equals method for a subclass, first call equals on the superclass. If that test doesn't pass, then the objects can't be equal. If the superclass fields are equal, you are ready to compare the instance fields of the subclass
public boolean equals(Employee other)
这里有什么问题呢？this method declares the explicit parameter type as Employee, as a result, it does not override the equals method of the Object class but defines a completely unrelated method
你可以显式地在method definition前加上@Override，告诉compiler你打算override某个method，如果你并没有override，compiler就会报错

(3)hashCode
a hash code is an integer (which can be negative) that is derived from an object
the hashCode method is defined in the Object class. Therefore, every object has a default hash code. The hash code is derived from the object's memory address
if you redefine the equals method, you will also need to redefine the hashCode method for objects that users might insert into a hash table
you definitions of equals and hashCode must be compatible: if x.equals(y) is true, then x.hashCode() must return the same value as y.hashCode()
也就是说，你的equals以什么为根据，那么hashCode也应当以它们为根据
重定义hashCode时常用如下方法：
Objects.hashCode(Object a)
Objects.hash(Object... objects)
Arrays.hashCode(type[] a)

(4)toString
returns a string representing the value of the object
the Object class defines the toString method to print the class name and the hash code of the object
most toString methods follow this format: the name of the class, then the field values enclosed in square brackets
为什么toString很重要呢？当你把一个object和一个string做+时，compiler会自动调用object的toString method to obtain a string representation of the object
"" + x比x.toString()更好，为什么呢？因为前者同样适用于primitive types
int[] nums = {2, 3, 5, 7, 11, 13}; nums.toString()的结果是什么呢？"[I@xxx"，其中"[I"表示an array of integers，更好的选择是Arrays.toString(nums)，结果是"[2, 3, 5, 7, 11, 13]"	
toString的一大用处是logging，we strongly recommend that you add a toString method to each class that you write. You, as well as other programmers who use you classes, will be grateful for the logging support

5.3 Generic Array Lists
(1)在Java中，虽然你可以在runtime时设置array的大小，但是一旦设置了大小，也就不能更改了，如果你需要一个可以随你添加或删除元素而自适应调整大小的array，ArrayList is for you；

(2)ArrayList也是class，而且是generic class，这里generic的含义是ArrayList可以存储任意类型的数据，具体数据类型通过type parameter来给定，比如，ArrayList<Employee>

(3)ArrayList<Employee> staff = new ArrayList<Employee>();
ArrayList<Employee> staff = new ArrayList<>();
从Java SE 7开始，右侧<>内的Employee可以省略
use the diamond syntax together with the new operator. The compiler checks what happens to the new value. If it is assigned to a variable, passed into a method, or returned from a method, then the compiler checks the generic type of the variable, parameter, or method. It then places that type into the <>
在Java SE 5.0之前，是没有generic class的，you can still use ArrayList without a <...> suffix, it is considered a "raw" type, with the type parameter erased
raw ArrayList不能控制add或set的元素是否是合法的类型，get回的元素还得显式cast，有很多坑，尽量不要使用
new ArrayList<>(100)和new Employee[100]
there is an important distinction between the capacity of an array list and the size of an array. If you allocate an array with 100 entries, then the array has 100 slots, ready for use. An array list with a capacity of 100 elements has the potential of holding 100 elements, but at the beginning, even after its initial construction, an array list holds no elements at all

(4)basic operations
staff.add(new Employee(...));
the array list manages an internal array of object references. If you call add and the internal array is full, the array list automatically creates a bigger array and copies all the objects from the smaller to the bigger array
staff.add(n, e)
staff.ensureCapacity(100);
你可以预估一下需要存储多少个元素，ensureCapacity能保证至少分配这么多空间
staff.size()
返回array list中实际存储的元素个数
staff.trimToSize()
staff.get(i)
staff.set(i, harry)
get和set为什么不能用[ ]呢？the reason is that the ArrayList class is not a part of the Java programming language; it is just a utility class programmed by someone and supplied in the standard library，而Java不支持operator overloading
有一种办法可以让你用到[ ]，那就是构建好ArrayList后调用toArray
X[] a = new X[list.size()];
list.toArray(a);
set只能用来替换元素，不要试图通过set添加元素
staff.remove(n)

(5)typed and raw array lists
我们说过了，不要使用raw ArrayList，typed ArrayList更安全可靠
那么对于历史遗留代码怎么办？难免可能碰到raw ArrayList
typed ArrayList到raw ArrayList，直接赋值就可以
raw ArrayList到typed ArrayList就比较麻烦了
ArrayList<Employee> result = employeeDB.find(query);
ArrayList<Employee> result = (ArrayList<Employee>) employeeDB.find(query);
上面这两种写法都不行，都提示warning。为什么第二个显式cast都不行呢？for compatibility, the compiler translates all typed array lists into raw ArrayList objects after checking that the type rules were not violated. In a running program, all array lists are the same, there are no type parameters in the virtual machine. Thus, the casts (ArrayList) and (ArrayList<Employee>) carry out identical runtime checks
所以，你也没有什么办法，确定warning可忽略的话，可以这样：
@SuppressWarnings("unchecked") ArrayList<Employee> result = (ArrayList<Employee>) employeeDB.find(query);

5.4 Object Wrappers and Autoboxing
(1)所有primitive types都有对应的class counterparts，比如int---Integer, short---Short, long---Long, byte---Byte, char---Character, float---Float, double---Double, boolean---Boolean，这些class称为wrappers；

(2)这些wrapper classes都是immutable的，另外，它们都是final的，即你不能subclass它们；

(3)wrappers有什么用呢？比如，你想构造一个array list of integers，但是很可惜，type parameter不能是primitive type，ArrayList<int>这种是不行的，此时，Integer就有用武之地了：
ArrayList<Integer> list = new ArrayList<>();
list.add(3);
等效于list.add(Integer.valueOf(3));
compiler自动进行的这种转换我们称为autoboxing
int n = list.get(i);
等效于int n = list.get(i).intValue();
Integer n = 3; n++
automatic boxing and unboxing even works with arithmetic expressions

(4)大部分情况下，primitive types和它们对应的wrappers就像没区别一样，需要注意的就是identity
Integer a = 1000; Integer b = 1000; 
a == b如何？可能为true，也可能为false，依赖于JVM的实现机制
当比较wrapper objects时，不要用a == b这种形式，用equals

(5)wrappers还有一个常用点是适合作为a convenient place to put certain basic methods
int x = Integer.parseInt(s);
这里其实完全和Integer没关系，parseInt是一个static method

(6)the boxing and unboxing is a courtesy of the compiler, not the virual machine. The compiler inserts the necessary calls when it generates the bytecodes of a class. The virtual machine simply executes those bytecodes

5.5 varargs
(1)public PrintStream printf(String fmt, Object... args);
... denotes that the method can receive an arbitrary number of objects
其实printf接收的就是两个参数，the format string and an Object[] array that holds all other parameters，也就是说，compiler将所有varargs组成了一个Object[]
如果传输的参数有primitive type values，compiler自动autoboxing
也就是说，对于printf的implementor来说，Object...就当作Object[]就好了
System.out.printf("%d %s", n, "widgets"); 
System.out.printf("%d %s", new Object[] {new Integer(n), "widgets"});

(2)you can define you own methods with variable parameters, and you can specify any type for the parameters, even a primitive type

(3)上面我们说，variable parameters被当作array处理，反过来，如果一个method的最后一个参数是array，那你把它改成variable parameters也没有问题，比如：
public static void main(String[] args)
public static void main(String... args)

5.6 Enumeration Classes
(1)public enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE };
the type defined by this declaration is actually a class
the class has exactly four instances, it is not possible to construct new objects

(2)you can add constructors, methods, and fields to an enumerated type:
public enum Size {
SMALL("S"), MEDIUM("M"), LARGE("L"), EXTRA_LARGE("XL");
private Size(String abbreviation) { this.abbreviation = abbreviation; }
public String getAbbreviation() { return abbreviation; }
private String abbreviation;
}
constructors是private的，所以你不能构造新的instances
the constructors are only invoked when the enumerated constants are constructed

(3)all enumerated types are subclasses of the class Enum
ordinal
Size.MEDIUM.ordinal()
toString
Size.SMALL.toString()
valueOf
Size s = Enum.valueOf(Size.class, "SMALL")

(4)each enumerated type has a static values method that returns an array of all values of the enumeration
Size[] values = Size.values()



5.8 Inheritance Design Hints
place common operations and fields in the superclass
don't use protected fields
protected methods can be useful to indicate methods that are not ready for general use and should be redefined in subclasses
use inheritance to model the "is-a" relationship
don't overuse inheritance, for example, Constractor-Employee fails the "is-a" test
don't use inheritance unless all inherited methods make sense
比如，Holiday继承GregorianCalendar就不合适
don't change the expected behavior when you override a method
the substitution principle applies not just to syntax but, more importantly, to behavior
when you override a method, you should not unreasonably change its behavior
you should not circumvent the intent of the original design when you override methods in subclasses
use polymorphism, not type information
code that uses polymorphic methods or interface implementations is much easier to maintain and extend than code using multiple type tests
don't overuse reflection
reflection is usually not appropriate in application programming
