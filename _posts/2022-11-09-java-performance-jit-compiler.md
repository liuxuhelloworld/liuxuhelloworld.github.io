The JIT (just-in-time) compiler is the heart of the JVM, nothing controls the performance of your application more than the JIT compiler.

Computers, more specifically CPUs, can execute only a relatively few, specific instructions, which are called *machine code*. All programs that the CPU executes must therefore be translated into these instructions. Language like C++ and Fortran are called *compiled languages* because their programs are delivered as binary code: the program is written, and then a static compiler produces a binary. The assembly code in that binary is trageted to a particular CPU. Languages like PHP and Perl, on the other hand, are interpreted. The same program source code can be run on any CPU as long as the machine has the correct interpreter. The interpreter translates each line of the program into binary code as that line is executed. For a number of reasons, interpreted code will almost always be measurably slower than compiled code: compilers have enough information about the program to provide optimizations to the binary code that an interpreter simply cannot perform.

Java attempts to find a middle ground here. Java applications are compiled, but instead of being compiled info a specific binary for a specific CPU, they are compiled into an intermediate low-level language. This language (known as *Java bytecode*) is then run the **java** binary (in the same way that an interpreted PHP script is run by the **php** binary). Because it is executing an idealized binary code, the **java** program is able to compile the code into the platform binary as the code executes. This compilation occurs as the program is executed: it happens "just in time".

# JIT in HotSpot JVM

The name (HotSpot) comes from the approach it takes toward compiling the code. In a typical program, only a small subset of code is executed frequently, and the performance of an application depends primarily on how fast those sections of code are executed. These critical sections are known as the hot spots of the application; the more the section of code is executed, the hotter that section is said to be.

When the JVM executes code, it does not begin compiling the code immediately. First, if the code is going to be executed only once, then compiling it is essentially a wasted effort; it will be faster to interpret the Java bytecodes than to compile them and execute (only once) the compiled code. The second reason is one of optimization: the more times that the JVM executes a particular method or loop, the more information it has about the code. This allows the JVM to make numerous optimizations when it compiles the code.